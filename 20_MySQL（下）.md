@[toc]
# 视图
## 视图是什么
通俗的讲，视图就是一条 SELECT 语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条 SQL 查询语句上。

视图是对若干张基本表的引用，一张==虚表（也是一张表，不过是一张特殊的表）==，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；方便操作，特别是查询操作，减少复杂的 SQL 

还有就是采用视图之后，可以做到让后端程序员无法进行修改相关数据，只能进行查询，就是有一个安全性的考量，并且代码写的也不会那么复杂。


## 定义视图
create view 视图名称 as select 语句；

给个例子：

```python
create view goods_view as 
	(select goods.id as id,goods.name as name,goods_cates.name as type from goods left join goods_cates on goods_cates.id=goods.cate_id)
```

## 查看视图
select * from 视图名

## 删除视图
drop view 视图名称

## 视图的作用
1. 提高了重用性，就像一个函数
2. 对数据库重构，却不影响程序的运行
3. 提高了安全性能，可以对不同的用户
4. 让数据更加清晰

# 事务
事务广泛的运用于订单系统、银行系统等多种场景
例如：
A 用户和 B 用户是银行的储户，现在 A 要给 B 转账 500 元，那么需要做以下几件事：
1. 检查 A 的账户余额>500 元；
2. A 账户中扣除 500 元;
3. B 账户中增加 500 元;

正常的流程走下来，A 账户扣了 500，B 账户加了 500，皆大欢喜。

那如果 A 账户扣了钱之后，系统出故障了呢？A 白白损失了 500，而 B 也没有收到本该属于他的 500。

以上的案例中，隐藏着一个前提条件：A 扣钱和 B 加钱，要么同时成功，要么同时失败。事务的需求就在于此，所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。例如，银行转帐工作：从一个帐号扣款并使另一个帐号增款，这两个操作要么都执行，要么都不执行。所以，应该把他们看成一个事务。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性

所以就引入了事务

## 事务的使用

```python
开启事务，命令如下（开启事务后执行修改命令，变更会维护到本地缓存中，而不维护到物理表中）
begin;  或者   start transaction;

提交事务，命令如下（将缓存中的数据变更维护到物理表中）
commit;

回滚事务，命令如下（ 放弃缓存中变更的数据）
rollback;
```

例子：

```python
# 开启事务
begin;
# 查询people1是否有500元
select money from bank where name='people1';
# people1转300元
update bank set money=money-300 where name='people1'
# people2收到300元
update bank set money=money+300 where name='people2'

执行结束后，进行查询数据库，这些数据是否都是正确的，正确的就可以：
commit;

如果是错误的：
rollback;

```

关于事务主要应用于高并发的情况下，有时候某线程会突然死掉，这种情况下就需要使用这种方式，==还有就是在没有commit的时候，你新建查询，去查询你操作的表，你的所有操作都是没有执行的，而在本张查询中（使用了begin的），你会发现你的查询和你的操作相关，减了就是减了（但实际上没减）==



# 索引
当数据库中数据量很大时，查找数据会变得很慢，优化方案：索引----就是数据结构(有序)，B+树索引（一般都是B+），哈希索引

## 查询索引
show index from 表名；
![[image/24f5a726ae1a76724ed3364c58a94998_MD5.png]]
## 创建索引
create index 索引名称 on 表名(字段名称(长度))

如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致

```python
创建索引
create index name1 on goods(name(255));

创建唯一索引，代表的就是这个索引所对应的那个东西必须是唯一的，比如这边就是price再表中必须是唯一的
create unique index price1 on goods(price);

创建联合索引 实际上就是我们查询的时候不是where 可能条件经常有 where  and 两种条件相结合的情况，这种情况下就需要联合索引

create index name2 on goods(name(255),price);
```

## 删除索引

```python
drop index 索引名称 on 表名;
```

## 聚集索引和非聚集索引
聚集索引实际上就是在sql进行索引存储的时候，他会把数据（data）也存到和索引一起的位置，而非聚集索引就是数据（data）存储的仅仅是表明是这个数据的标记，然后会再通过这个标记去寻找对应的数据

==所以说一张表实际上对应的就只有一个聚集索引，也绝大多数都是利用主键进行索引区分，然后再MySQL中，其他新建的索引也就是非聚集索引下存储的数据都是对应的id，然后再通过id再去寻找对应的数据。==


## 影响
1. 提高删除 查询 修改的速度。
2. 减少新增的速度，因为新增的时候需要多经过索引，然后再插入数据。


# 账户管理（了解非DBA）
1.  在生产环境下操作数据库时，绝对不可以使用 root 账户连接，而是创建特定的账户，授予这个账户特定的操作权限，然后连接进行操作，主要的操作就是数据的 crud
2. MySQL 账户体系：根据账户所具有的权限的不同，MySQL 的账户可以分为以下几种：

|账户|说明|
|-|-|
|服务实例级账号|启动了一个 mysqld，即为一个数据库实例；如果某用户如 root,拥有服务实例级分配的权限，那么该账号就可以删除所有的数据库、连同这些库中的表|
|数据库级别账号|对特定数据库执行增删改查的所有操作|
|数据表级别账号|对特定表执行增删改查等所有操作|
|字段级别的权限|对某些表的特定字段进行操作|
|存储程序级别的账号|对存储程序进行增删改查的操作|
3. 账户的操作主要包括创建账户、删除账户、修改密码、授权权限等
4. 进行账户操作时，需要使用 root 账户登录，这个账户拥有最高的实例级权限
5. 通常都使用数据库级操作权限

## 授予权限 与 账户的相关操作
[参考连接](https://blog.csdn.net/csdn_myhome/article/details/131871702)
笔者这边数据库出现问题，没实操过，所以没总结OxO 尴尬


# MySQL的主从配置

[相关链接](https://blog.csdn.net/isis45454545454/article/details/126510152?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169332086316800197050879%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169332086316800197050879&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~baidu_landing_v2~default-1-126510152-null-null.268%5Ev1%5Ekoosearch&utm_term=mysql%208.0%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE&spm=1018.2226.3001.4450)

实际上所做的事情就是读写分离，比如一台机器专门用来读数据，一台机器专门用来写数据，然后读数据的机器所作的事情实际上是隔一段时间，去写机器那边进行到处bin.log，也就是二进制文件（sql底层引擎使用的东西），然后进行同步数据库。


主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。

使用主从同步的好处：
1. 通过增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上向外提供读功能，可以动态地调整从服务器的数量，从而调整整个数据库的性能。
2. 提高数据安全，因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据
3. 在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能

