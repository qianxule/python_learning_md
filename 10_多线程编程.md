@[TOC]
# 多任务的概念
什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听 MP3，一边在用 Word 赶作业，这就是多任务，至少同时有 3 个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。

现在，多核 CPU 已经非常普及了，但是，即使过去的单核 CPU，也可以执行多任务。由于 CPU 执行代码都是顺序执行的，那么，单核 CPU 是怎么执行多任务的呢？
    
答案就是操作系统轮流让各个任务交替执行，任务 1 执行 0.01 秒，切换到任务2，任务 2 执行 0.01 秒，再切换到任务 3，执行 0.01 秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于 CPU 的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。

真正的==并行==执行多任务只能在多核 CPU 上实现，但是，由于任务数量远远多于CPU 的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。

## 注意
并发：指的是任务数多余 cpu 核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）

并行：指的是任务数小于等于 cpu 核数，即任务真的是一起执行的

# 线程
线程不能独立存在，必须依附于进程而进行存在。（所以个人理解==进程实际上就可以看作是一个主线程==）

python 的 thread 模块是比较底层的模块，python 的threading 模块是对 thread 做了一些包装的，可以更加方便的被使用。

## 基本的调用

```python
import threading
import time

def saySorry():
	print("亲爱的，我错了，我能吃饭了吗？")
	time.sleep(1)
	
if __name__ == "__main__":
	for i in range(5):
		t = threading.Thread(target=saySorry)
		t.start() #启动线程，即让线程开始执行
```
1. 可以明显看出使用了多线程并发的操作，花费时间要短很多，实际上就是一瞬间由父进程几乎同时创建了5个线程去执行saySorry的函数，然后也是几乎同时就开始了start执行，然后5个线程又几乎同时等待1s的时间。
2. 当调用 start()时，才会真正的创建线程，并且开始执行。
3. 进程（~~主线程~~ ）会等待所有的子线程结束后才结束

## 查看线程的数量
在Linux下使用

```python
# 方法1：
ps -elLf|grep 线程的名字（这个py程序的名字）

# 方法2：
top 按H开始查看线程

```

## 线程代码的封装（与进程类似，进程篇章忘记补充了）
通过使用 threading 模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用 threading 模块时，往往会定义一个新的子类 class，只要继承 threading.Thread 就可以了，然后重写 run 方法即可。创建自己的线程实例后，通过 Thread类的 start 方法，可以启动该线程，交给 python 虚拟机进行调度，当该线程获得执行的机会时，就会调用 run 方法执行线程。

```python
import threading
import time

class MyThread(threading.Thread):
	def run(self):
		for i in range(3):
			time.sleep(1)
			msg = "I'm "+self.name+' @ '+str(i) #name 属性中保存的是当前线程的名字
			print(msg)


if __name__ == '__main__':
	t = MyThread()
	t.start()
```

## 线程的执行顺序

```python
import threading
import time

class MyThread(threading.Thread):
	def run(self):
		for i in range(3):
			time.sleep(1)
			# 每一个线程都有自己相对应的名字，即使你没有定义，可以使用self.name进行调用。
			msg = "I'm "+self.name+' @ '+str(i) 
			print(msg)
			
def test():
	for i in range(5):
		t = MyThread()
		t.start()

if __name__ == '__main__':
	test()
```
执行的结果：

```python
I'm Thread-1 @ 0
I'm Thread-2 @ 0
I'm Thread-5 @ 0
I'm Thread-3 @ 0
I'm Thread-4 @ 0
I'm Thread-3 @ 1
I'm Thread-4 @ 1
I'm Thread-5 @ 1
I'm Thread-1 @ 1
I'm Thread-2 @ 1
I'm Thread-4 @ 2
I'm Thread-5 @ 2
I'm Thread-2 @ 2
I'm Thread-1 @ 2
I'm Thread-3 @ 2
```

说明：
从代码和执行结果我们可以看出，多线程程序的执行顺序是不确定的。当执行到sleep 语句时，线程将被阻塞（Blocked），到 sleep 结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个 run 函数，但是线程的启动顺序、run 函数中每次循环的执行顺序都不能确定。

==但是值得关注的是：无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。==


## 多线程-共享全局变量

```python
from threading import Thread
import time

g_num = 100

def work1():
	global g_num
	for i in range(3):
		g_num += 1
	print("----in work1, g_num is %d---"%g_num)
	
def work2():
	global g_num
	print("----in work2, g_num is %d---"%g_num)


print("---线程创建之前 g_num is %d---"%g_num)	
t1 = Thread(target=work1)
t1.start()
#延时一会，保证 t1 线程中的事情做完
time.sleep(1)
t2 = Thread(target=work2)
t2.start()

```
执行结束后的结果：

```python
---线程创建之前 g_num is 100---
----in work1, g_num is 103---
----in work2, g_num is 103---
```

说明：
1. 在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据。
2. 缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）

## 注意点
1. 由于python的GIL锁的问题，在任意时刻只允许单个Python线程执行。无论系统存在多少个可以应用的CPU核心，python程序都只能在一个处理器中进行执行。==也就是说，无论你创建了多少个线程，都无法让这些线程到多个核上分别执行（这个和C++/java有很大的区别，值得关注）==
2. 而上一篇当中我们发现对于多进程来说，当父亲进程先执行结束，子进程可能仍然在执行，也就是孤儿进程会发生，或者也会发生僵尸进程等，也就是说为了避免这一些操作，我们可以通过调用join函数进行控制，但是对于线程也可以，除非为了控制俩线程执行顺序上的先后关系，不然是没有相关的必要性的，线程的资源最后都会被进程进行回收。


# 互斥锁
## 多线程-共享全局变量可能会发生的问题（解决的问题）

```python
import threading
import time

g_num = 0

def work1(num):
	global g_num
	for i in range(num):
		g_num += 1
	print("----in work1, g_num is %d---"%g_num)
	
def work2(num):
	global g_num
	for i in range(num):
		g_num += 1
	print("----in work2, g_num is %d---"%g_num)


print("---线程创建之前 g_num is %d---"%g_num)
t1 = threading.Thread(target=work1, args=(1000000,))
t1.start()
t2 = threading.Thread(target=work2, args=(1000000,))
t2.start()
while len(threading.enumerate()) != 1:
	time.sleep(1)
print("2 个线程对同一个全局变量操作之后的最终结果是:%s" % g_num)
```
输出的结果：

```python
---线程创建之前 g_num is 0---
----in work1, g_num is 1088005---
----in work2, g_num is 1286202---
```
分析：
原因实际上就是由于+1指令不为原子指令，实际上也就是当数据在从内存调用到加法寄存器当中的时候，时间片突然结束，轮到下一个线程进行执行的时候，发生的数据少加一次，也就是说：如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确。

## 同步的概念
同步就是协同步调，按预定的先后次序进行运行。如:你说完，我再说。"同"字从字面上容易理解为一起动作其实不是，"同"字应是指协同、协助、互相配合。
如进程、线程同步，可理解为进程或线程 A 和 B 一块配合，A 执行到一定程度时要依靠 B 的某个结果，于是停下来，示意 B 运行;B 执行，再将结果给 A;A 再继续操作。 

解决线程同时修改全局变量的方式：
对于上一小节提出的那个计算错误的问题，可以通过线程同步来进行解决思路，如下:
1. 系统调用 t1，然后获取到 g_num 的值为 0，此时上一把锁，即不允许其他线
程操作 g_num
2. t1 对 g_num 的值进行+1
3. t1 解锁，此时 g_num 的值为 1，其他的线程就可以使用 g_num 了，而且是
g_num 的值不是 0 而是 1
4. 同理其他线程在对 g_num 进行修改时，都要先上锁，处理完后再解锁，在上
锁的整个过程中不允许其他线程访问，就保证了数据的正确性 

## 互斥锁
当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。

互斥锁为资源引入一个状态：锁定/非锁定
某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。

threading 模块中定义了 Lock 类，可以方便的处理锁定：

```python
# 创建锁
mutex = threading.Lock()
# 锁定
mutex.acquire()
# 释放
mutex.release()
```
注意点：
1. 如果这个锁之前是没有上锁的，那么 acquire 不会堵塞
2. 如果在调用 acquire 对这个锁上锁之前 它已经被 其他线程上了锁，那么此时acquire 会堵塞，直到这个锁被解锁为止。、

### 样例

```python
import threading
import time

g_num = 0

def test1(num):
	global g_num
	for i in range(num):
		mutex.acquire() # 上锁
		g_num += 1
		mutex.release() # 解锁
	print("---test1---g_num=%d"%g_num)

def test2(num):
	global g_num
	for i in range(num):
		mutex.acquire() # 上锁
		g_num += 1
		mutex.release() # 解锁
	print("---test2---g_num=%d"%g_num)

# 创建一个互斥锁
# 默认是未上锁的状态
mutex = threading.Lock()
# 创建 2 个线程，让他们各自对 g_num 加 1000000 次
p1 = threading.Thread(target=test1, args=(1000000,))
p1.start()
p2 = threading.Thread(target=test2, args=(1000000,))
p2.start()
# 等待计算完成
while len(threading.enumerate()) != 1:
	time.sleep(1)
print("2 个线程对同一个全局变量操作之后的最终结果是:%s" % g_num)
```

### 总结
锁的好处：
1. 确保了某段关键代码只能由一个线程从头到尾完整地执行

锁的坏处：
1. 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了
2. 由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成==死锁==


# 死锁
在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。尽管死锁很少发生，但一旦发生就会造成应用的停止响应。下面看一个死锁的例子

```python
import threading
import time

class MyThread1(threading.Thread):
	def run(self):
		# 对 mutexA 上锁
		mutexA.acquire()
		# mutexA 上锁后，延时 1 秒，等待另外那个线程 把 mutexB 上锁
		print(self.name+'----do1---up----')
		time.sleep(1)
		# 此时会堵塞，因为这个 mutexB 已经被另外的线程抢先上锁了
		mutexB.acquire()
		print(self.name+'----do1---down----')
		mutexB.release()
		# 对 mutexA 解锁
		mutexA.release()

class MyThread2(threading.Thread):
	def run(self):
		# 对 mutexB 上锁
		mutexB.acquire()
		# mutexB 上锁后，延时 1 秒，等待另外那个线程 把 mutexA 上锁
		print(self.name+'----do2---up----')
		time.sleep(1)
		# 此时会堵塞，因为这个 mutexA 已经被另外的线程抢先上锁了
		mutexA.acquire()
		print(self.name+'----do2---down----')
		mutexA.release()
		# 对 mutexB 解锁
		mutexB.release()


mutexA = threading.Lock()
mutexB = threading.Lock()
if __name__ == '__main__':
	t1 = MyThread1()
	t2 = MyThread2()
	t1.start()
	t2.start()
```

## 避免死锁的产生
1. 程序设计时要尽量避免（银行家算法）
2. 添加超时时间等

银行家算法是一种用于避免死锁的资源分配和调度算法，最初由Edsger Dijkstra提出。它是基于银行家的信贷系统的概念，用于确保在分配资源时不会陷入死锁状态。

在银行家算法中，系统中的资源被分为多个类型，并且为每个进程和系统分配一个最大需求的资源数量。算法通过检查当前系统的资源分配状态和进程的资源请求来决定是否分配资源，以避免可能导致死锁的情况。

银行家算法的基本思想是，当一个进程请求资源时，系统会先检查分配给该进程的资源是否满足请求，如果满足则分配资源，否则进程必须等待。在分配资源后，系统会检查是否存在安全序列，即一系列进程按照顺序完成并释放资源而不会导致死锁。如果存在安全序列，则分配资源；否则，拒绝分配资源，以避免可能导致死锁的情况。

银行家算法的核心目标是确保资源的安全性和有效性，以避免死锁的发生。它是一种重要的算法，广泛应用于操作系统和并发编程中，特别是在多进程或多线程环境下的资源管理和调度中。

